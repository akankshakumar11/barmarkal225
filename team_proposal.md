## Leading Question
Given the airport dataset from OpenFlights, what is the quickest route/flight itinerary from any valid user-inputted origin airport to any valid user-inputted destination airport, with the least number of layovers/connections? We aim to solve these problems using Dijkstra’s algorithm. In addition, we will be exploring a secondary question: “which airports are the most important?” Because an airport’s importance can be determined using different criteria, we will address two of these possible criteria using the betweenness centrality algorithm and the PageRank algorithms.

## Dataset Acquisition
We will acquire our flight/airport dataset from the website OpenFlights.org. The dataset we will be working with is a CSV file that contains a data entry of every airport in the world, along with its location and IATA code. There is an option available of downloading and working with "airports-extended.dat", which contains train stations and ferry terminals in addition to airports, but we will not be using this dataset while working on our project because we would like to start with a simpler version first and ensure that our code works on a base level. Later on, we may be able to modify our code to accommodate for train stations and ferries too. However, for now, we will focus on just airport data. 

## Data Format
As stated above, we will acquire our dataset from OpenFlights.org as a CSV file titled "airports.dat", which contains a data entry of every airport in the world, along with its location and IATA code, in addition to other relevant characteristics. The file we are using contains 14,110 airport data entries. For initial testing, we will use a small subset of approximately 100 airports, preferably from different countries and continents, and then when we are sure our code works, we will graduate to the overall dataset and test and finalize using that. 

## Data Correction
With regards to data correction, we will first experiment with the dataset using Python on Google Colab to determine whether there are any glaring errors or inconsistencies. After filtering out the statistics and characteristics that are not relevant to our project and leading question, we will then simply test on that filtered data, and if we happen to run into any errors while testing that are not resulting from bugs in our code, then we will sift through the dataset and our failed test cases to figure out what the issue is and further adjust our filtered dataset to accommodate for those issues.

## Data Storage
We plan on using a map to store the dataset itself. The key in this dataset map will be an airports IATA code, as that is how we plan on having the users input their desired origin and destination airports IDs. The value of the dataset map will be an array of any other criteria/characteristics of an airport that we deem necessary for our algorithm later on. The index of this array will correspond to a different characteristic, so for example array[0] of the value of a given key will give that airport's location as a string, while array[1] will give the exact latitude/longitude position. Additionally, as a part of our algorithm we will be using a stack for our BFS (breadth first search). In the event that we use additional data structures in our code, we will update this section with those structures and their respective purposes. The runtime for our algorithm as of now should be $O(n^2)$ for the storage portion of the algorithm/the function(s) that parse and store our data structure. One $n$ will be from iterating through the map for the key, and the other $n$ will be from storing the remaining characteristics in the value arrays.

## Algorithm
The expected input for our algorithm is the airport dataset itself, and the user input, which would be two IATA codes that correspond to the desired origin and destination airports. Our airport data is in a large CSV file. We will parse through this CSV file using read functions, and store this information in our map structure, as discussed in the Data Storage section. Once we are done constructing this storage map, the next step is traversing through the stored data in order to find the shortest path. For this, we will be using a stack and BFS. Dijkstra's Algorithm is used for finding the shortest path between two nodes on a graph. We will begin by using this algorithm, using the stored data as an input and expecting an array of IATA codes representing the output of the best flight itinerary. This will help us address our question about what the shortest path between any valid user-inputted origin airport to any valid user-inputted destination airport is.

We will be addressing another question: which airports are the most important? There are two ways to determine this, and we will outline them using the two methods described below.

One way to decide which airports are most important is by finding which airports have the most (and as a result, are the best for) connecting flights in the shortest paths we found previously. We will determine this using the betweenness-centrality algorithm.  For this algorithm, we will set up unweighted edges connecting the keys of the map (which represent the nodes) and calculate the number of shortest paths each airport serves as a “bridge” for. We will set this number over the total number of shortest paths to find the centrality of the airport. This will be done for each airport in order to determine how they compare to each other.

Another way to determine the importance of certain airports is by representing the airport flight data as a directed graph (with flights being the edges and vertices being the source and destination airports) and ordering the airports according to the PageRank algorithm. This will help us calculate the order of airport popularity, which will finally help in determining the absolute best possible flight itinerary given the origin and destination IATAs. In a similar way to how the PageRank algorithm is used to determine the importance of certain websites based on how many other websites contain links to that particular website, we will be using the algorithm (with the input being a directed graph representing the shortest path between airports found by using Djikstra’s algorithm) to output a ranking of  the airports based on how many airports have flights going into that particular airport.  

## Timeline
In terms of timeline, our goal for this week was to formulate a rough plan for the remainder of our project, including the specific data structures and algorithms we need to construct working code that answers/solves our leading question. We also created a document where we have compiled resources and articles and documentation regarding the algorithms listed above in the algorithm section in order for us to understand these algorithms and then smoothly construct and carry the our overall program. By next week, we would like to have a working read/parse/store function that reads in the airports.dat CSV file and properly stores it in our data structure (in our case, a map, although this may be subject to change if we discuss and determine a more efficient structure). We will begin working on our actual popularity and traversal and path calculation algorithms in the weeks following, but as for now, our main goal is to figure out the parsing and storing of the dataset by next week.
