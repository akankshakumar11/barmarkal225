## Project Results

Over the course of the project, we successfully parsed railroad notes and connections into a graph of railroad Nodes and weighted path Edges and created implementations for a **BFS** traversal, **PageRank** algorithm, and **A\*** algorithm. Our project is organized into modules that can be individually run as well as an overall main that displays all of our results. We answered our leading question, which asked how to find routes among stations and rank them given a dataset of railroad stations and connections.

Our original proposal was to create a class planner with courses as Nodes and prerequisite relationships as Edges. However, after discussing with our project mentor, we switched projects to investigate Amtrak railroads in North America. Since we spent the first week finding a new project and writing the new proposal, we had to work quickly to accomplish all of goals. However, we managed to successfully complete the project and are very satisfied with our discoveries.

From our **BFS** implementation, we found that there were significantly more connected components in the railroad graph network than we had initially thought. From our initial research of the Federal Railroad Administration, we had reasonably expected that most connected components would have at minimum 100 stations (nodes), but we were surprised to find that there was even a connected component with only 12 stations connected to one another. 

**PageRank** is an algorithm that uses Markov matrices and power iteration to estimate the usage of each railroad station based on its connections to other stations. Using power iteration finds the eigenvector corresponding to what percent of total traffic is predicted to pass through each station. By implementing and running PageRank on 1000 stations in Illinois, we discovered that many railroad stations only have a few connections, and the most prominent railroad station of the ones we used for PageRank was had ID 396218, which is located at coordinates `(38.5970828140417, -90.1482938530148)`, right on the border of St. Louis. We looked at these coordinates in (Google Maps)[https://www.google.com/maps/place/38%C2%B035'49.5%22N+90%C2%B008'53.9%22W/@38.5679168,-90.2686174,10.92z/data=!4m5!3m4!1s0x0:0x0!8m2!3d38.5970828!4d-90.1482939] to confirm that they correspond to a railroad station. When coding the PageRank algorithm, we also discovered that power iteration converges much faster than we expected. While PageRank time complexity is `O(k * (m+n))` where `k` is the number of iterations, `m` is the number of edges, and `n` is the number of nodes, PageRank converged very quickly even with max iterations of 1000, tolerance of 10^(-6), and 1000 nodes.

**A\*** is a pathfinding algorithm similar to Dijkstra's, which we learned in class. The difference is that A* checks nodes in a certain order which Dijkstra checks nodes in the order they are added to the queue. A* sorts nodes using a heuristic or cost function that assigns values to nodes using a user defined function. For out heuristic, we used distance. This means that the algorithm will check nodes closest to the destination first. This can drastically change run time since an effective heuristic means that you don't need to to test every single node. We used the Haversine formula for distance, which takes the longitude and latitude of 2 points and finds the distance between them in kilometers while taking the curve of the Earth into account. This is the most effective distance formula for us to use since the railroad stations provide real world latitude and longitude coordinates. This lead me to the discovery that changing the cost function slightly can drastically how A* runs and how quick it runs. Using a simple distance formula instead of the haversine formula made the program run longer and provide a route longer than the shortest one.

As for the final deliverables for our project, we have compiled several testing files that thoroughly test each component of the project. These can be run individually within each components corresponding folder. The hierarchical structure of our final project is such that the root directory contains subfolders corresponding to each component ("bfs", "pagerank", "a_star"). Within each folder we have a `include` folder for header files and `src` folder for source code. Along with our code, within these folders, we have a `tests` folder containing test cases. There is also a `main.cpp` file within each component that executes the algorithm's implementation in some capacity. The `BFS` main file initiates a BFS traversal on the first node in the dataset. The `PageRank` main file runs the PageRank algorithm on the nodes whose IDs are listed in `node.txt`, which the user can modify to choose which stations to evaluate; outputs the full solution to `pagerank.txt`; and prints the best ranked station to the console. The `A*` main file takes a graph, start node, and end node and runs the a star algorithm on the graph. It takes in a vector of node pointers and the start and end positions refer to what position the nodes are in the vector, not their railroad ID's.
