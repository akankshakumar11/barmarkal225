# Algorithms & outputs


## Breadth-First Search (BFS)
In BFS, we traverse through a graph by level, marking nodes as visted and unvisited until we determine the shortest paths with regards to least number of steps from a start node to an end node. In our program, we use BFS to determine the shortest path between two given airports. For example, if the start airport is CMI and the destination airport is SFO, our algorithm determines that there is no direct flight from CMI to SFO, and so using BFS, it figures out that one such possible shortest flight from CMI to SFO is CMI->DFW->SFO. An important thing to remember about BFS is that it only finds shortest path with regards to least number of steps, so it will not take distance into account. In addition, based on the datatset and the way the data is stored in the graph used in BFS, the output will not necessarily be consistent because two airports can have multiple different "shortest paths" that all have the same number of layovers, but stop in diferent places. For a more reliable algorithm, see Dijkstra's shortest path algorithm. To test BFS, we used a smaller graph that would lead to consistent outputs, which we could then check. See main.cpp for these test cases. 

## Dijkstra's algorithm
Dijkstra's algorithm is used for determining the shortest path in a graph from any given vertex to a different one. One of the main differences between Dijkstra's and BFS is that unlike BFS, Dijkstra's can be used to determine shortest path while taking edge weightages into account. BFS will only work on unweighted graphs. So in the context of our problem and program, if we use a dataset of airplane routes that includes a data attribute representing distance between airports, we can factor that attribute in to our final shortest path calcualtion, so that instead of returning paths that simply have the least number of layovers, we can filter out those paths so only the ones with shortest distance AND least layovers remains. So for example, if we were looking for flights from CMI to SFO (Champaign to San Francisco), instead of returning a trip from CMI to MIA to SFO (stopover in Miami), Dijkstra's will return CMI to DFW to SFO (stopver in Dallas/Fort Worth). In context of the problem, though both trips have the same number of layovers, it does not make sense to fly away from the destination before going towards it, when you can just have a layover that is at least between the origin and destination. Our test cases of Dijkstra's algorithm uses this same scenario, and you can see that it correctly returns the DFW trip as the output.

## PageRank
The PageRank algorithm was first developed to rank web pages in Google search engine results and display the pages by popularity. We have implemented PageRank in our program to use the data on airports and airplane routes to determine the most "popular" airports with regards to how likely it is for a fligth to pass through a given airport with a large number of overall flights. The airports with the largest number of incoming and outgoing flights are ranked as most popular. PageRank allows us to create and return a list of the most popular airports globally to the user, who can then take that knowledge into account with regards to planning their next trip. To test our PageRank algorithm, we wrote up test cases included in the main file that uses the full routes.dat CSV dataset representing all airplane routes throughout the world. The ourput shows us the most popular airports, and aligns with our expected values.

## Betweenness Centrality algorithm
Betweeness Centrality makes use of both BFS and Dijkstra's to calculate the "centrality" of each vertex in the graph, in this case an aipport. Centrality is a measure of how "central" a vertex is with regards to the overall graph, so in context of our problem, it is essentially a numerical value that gives us an idea of which airports are "hubs". So if an airport, such as DFW (Dallas/Fort Worth) has a high centrality value returned by this Betweenness Centrality algorithm, that means it likely has a lot of incoming and outgoing flights and is a pretty important airport with lots of flight paths likely containing it. Betweenness Centrality works with both weighted and unweighted graphs. In the case of an unweighted graph, the algorithm will use BFS, but with weighted, it will implement Dijkstra's. The betweenness centrality algorithm returns a map containing keys which are Nodes representing all airports, and values which are doubles representing the corresponding centrality measures of each airport. Though we implemented the betweenness centrality algorithm, we did not end up using or testing it, as we ran out of time, and it was an extra algorithm on top of the required algorithms.


# Leading question & answer
Our leading question was: Given a dataset of all flights, what is the quickest route from any valid origin airport to any valid destination airport, with the least number of connections/layovers?
What we learned was that though there are quite a few different algorithms to determine the answer to this question, but some are more reliable than others, especially wihtin the context of this specific problem. For example, we knew that BFS was an algorithm for determining shortest path. Though this is technically true, this algorithm alone cannot correctly and consistently answer our leading question, because our question involves flights, and distance and flight time matters with regards to determining the true shortest paths. For example, though both BNA->DFW->LAX and BNA->MCO->LAX will get you from Nashville to LA, one of the flights has a layover in Texas, while the other has a layover in Florida. As a passenger, you would not want to fly in the opposite direction of your destination, as that would obviously cost you unecessary time and energy. However, our BFS algorithm can potentially return both paths as a valid "shortest path", because it does not take distance into account. To solve this, we need to implement Dijkstra's algorithm. This algorithm takes weightages into account, so using the routes and airport datasets, we can use distance between airports as weightages to correctly and consistently determine the true shortest path between two airports. Our project was not as successful as we would have liked, as not all of our outputs for each algorithm we had planned ended up consistently working - however, we were able to correctly answer our leading quesiton with our desired input of finding the shortest flights from Champaign to San Francsico. Some things we would keep in mind if we were to do this again would be time management and communication. As the project deadline was during finals week, it became quite tough to complete everything we wanted in time, but thanks to our communication, we were able to at least answer our leading question through our algorithms.
